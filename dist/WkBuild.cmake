# 
# Copyright (c) 2009, Asmodehn's Corp.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
# 
#     * Redistributions of source code must retain the above copyright notice, 
#	    this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#		notice, this list of conditions and the following disclaimer in the 
#	    documentation and/or other materials provided with the distribution.
#     * Neither the name of the Asmodehn's Corp. nor the names of its 
#	    contributors may be used to endorse or promote products derived
#	    from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
#

#debug
message ( STATUS "== Loading WkBuild.cmake ..." )

if ( CMAKE_BACKWARDS_COMPATIBILITY LESS 2.6 )
	message ( FATAL_ERROR " CMAKE MINIMUM BACKWARD COMPATIBILITY REQUIRED : 2.6 !" )
endif( CMAKE_BACKWARDS_COMPATIBILITY LESS 2.6 )

#test to make sure necessary variables have been set.

if ( NOT WKCMAKE_DIR OR NOT WKCMAKE_INCLUDE_DIR OR NOT WKCMAKE_SRC_DIR ) 
	message( FATAL_ERROR "You need to include WkCMake.cmake in your CMakeLists.txt, and call WkCMakeDir(<path_to WkCMake scripts> )" )
endif ( NOT WKCMAKE_DIR OR NOT WKCMAKE_INCLUDE_DIR OR NOT WKCMAKE_SRC_DIR ) 

# using useful Macros
include ( "${WKCMAKE_DIR}/WkUtils.cmake" )

# To detect the Platform
include ( "${WKCMAKE_DIR}/WkPlatform.cmake")

#To setup the compiler
include ( "${WKCMAKE_DIR}/WkCompilerSetup.cmake" )

macro(WkProject project_name_arg)
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)
	project(${project_name_arg} ${ARGN})
	WkPlatformCheck()
	WkCompilerSetup()
	#preparing and cleaning internal build variables
	# We might not need that at all : simpler
	#set( ${PROJECT_NAME}_INCLUDE_DIRS CACHE PATH " Includes directories for ${PROJECT_NAME} ")
	#set( ${project_name_arg}_LIBRARIES CACHE FILEPATH " Libraries needed for ${project_name_arg} " )
	#set( ${project_name_arg}_RUN_LIBRARIES CACHE FILEPATH " libraries needed to run ${project_name_arg} " )

	#TODO
	#Quick test to make sure we build in different directory
	#if ( ${PROJECT_SOURCE_DIR} STREQUAL ${PROJECT_BINARY_DIR} )
	#	SET(PROJECT_BINARY_DIR "${PROJECT_BINARY_DIR}/build" )
	#endif ( ${PROJECT_SOURCE_DIR} STREQUAL ${PROJECT_BINARY_DIR} )
CMAKE_POLICY(POP)
endmacro(WkProject PROJECT_NAME)

#
# Generate a config file for the project.
#
# Automatically called during WkBuild
#

macro ( WkGenConfig )
	CMAKE_POLICY(PUSH)
	CMAKE_POLICY(VERSION 2.6)

	#Exporting targets
	export(TARGETS ${PROJECT_NAME} FILE ${PROJECT_NAME}Export.cmake)
	
	#Generating config file
	file( WRITE ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "### Config file for ${PROJECT_NAME} auto generated by WkCmake ###

### First section : Main target ###
IF(\${CMAKE_MAJOR_VERSION}.\${CMAKE_MINOR_VERSION} LESS 2.5)
   MESSAGE(FATAL_ERROR \"CMake >= 2.6.0 required\")
ENDIF(\${CMAKE_MAJOR_VERSION}.\${CMAKE_MINOR_VERSION} LESS 2.5)
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)
	
get_filename_component(SELF_DIR \"\${CMAKE_CURRENT_LIST_FILE}\" PATH)
#all required target should be defined there... no need to specify all targets in ${PROJECT_NAME}_LIBRARIES, they will be linked automatically
include(\${SELF_DIR}/${PROJECT_NAME}Export.cmake)
get_filename_component(${PROJECT_NAME}_INCLUDE_DIR \"\${SELF_DIR}/${WKCMAKE_INCLUDE_DIR}/\" ABSOLUTE)
set(${PROJECT_NAME}_INCLUDE_DIRS \"\${SELF_DIR}/CMakeFiles\" )
	")
	
	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
#however we still want to have ${PROJECT_NAME}_LIBRARIES available
set(${PROJECT_NAME}_LIBRARY ${PROJECT_NAME} )
set(${PROJECT_NAME}_LIBRARIES \"\${${PROJECT_NAME}_LIBRARY}\")
	" )
	
	get_target_property(${PROJECT_NAME}_LOCATION ${PROJECT_NAME} LOCATION)
	get_target_property(${PROJECT_NAME}_TYPE ${PROJECT_NAME} TYPE)
	if ( ${${PROJECT_NAME}_TYPE} STREQUAL "SHARED_LIBRARY" OR ${${PROJECT_NAME}_TYPE} STREQUAL "MODULE_LIBRARY")
		file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
		
#On windows we need to copy the dlls as running dependencies along with the project's executable(s)
#as a complement to the cmake mechanism...
if ( WIN32 )
		set(${PROJECT_NAME}_RUN_LIBRARIES \"${${PROJECT_NAME}_RUN_LIBRARIES}\" )
endif ( WIN32)

		")
	endif ( ${${PROJECT_NAME}_TYPE} STREQUAL "SHARED_LIBRARY" OR ${${PROJECT_NAME}_TYPE} STREQUAL "MODULE_LIBRARY")
	
	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
set(${PROJECT_NAME}_FOUND TRUE)
	")	
	
	CMAKE_POLICY(POP)
endmacro ( WkGenConfig )

#
# WkFinConfig () finalizes the configuration file, by
# creating the necessary lines in the config file for detection by other projects.
#
macro(WkFinConfig )
	CMAKE_POLICY(PUSH)
	CMAKE_POLICY(VERSION 2.6)

	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
#Includes for project after dependencies' includes
set(${PROJECT_NAME}_INCLUDE_DIRS \"\${${PROJECT_NAME}_INCLUDE_DIRS}\" \"\${${PROJECT_NAME}_INCLUDE_DIR}\" )

#Displaying detected dependencies in interface, and storing in cache
set(${PROJECT_NAME}_INCLUDE_DIRS \"\${${PROJECT_NAME}_INCLUDE_DIRS}\" CACHE PATH \"${PROJECT_NAME} Headers\" )
set(${PROJECT_NAME}_LIBRARIES \"\${${PROJECT_NAME}_LIBRARIES}\" CACHE FILEPATH \"${PROJECT_NAME} Libraries\")
if ( WIN32 )
	set(${PROJECT_NAME}_RUN_LIBRARIES \"\${${PROJECT_NAME}_RUN_LIBRARIES}\" CACHE FILEPATH \"${PROJECT_NAME} DLLs\" )
endif ( WIN32 )	

CMAKE_POLICY(POP)
	
	")

	CMAKE_POLICY(POP)
endmacro(WkFinConfig )


#
# Configure and Build process based on well-known hierarchy
# You need include and src in your hierarchy at least for this to work correctly
# You also need MergeLists.txt 
#

#WkBuild( target_name EXECUTABLE | LIBRARY [ STATIC|SHARED|MODULE ]  )

macro (WkBuild project_type)
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)


	if ( ${ARGC} GREATER 1 )
		set(${PROJECT_NAME}_load_type ${ARGV1} )
	endif ( ${ARGC} GREATER 1 )

	message ( STATUS "== Configuring ${PROJECT_NAME} as ${project_type} ${${PROJECT_NAME}_load_type}" )	
		
	# testing type
	if (NOT ${project_type} STREQUAL "EXECUTABLE" AND NOT ${project_type} STREQUAL "LIBRARY" )
		message ( FATAL_ERROR " Project type ${project_type} is not valid. Project type can be either EXECUTABLE or LIBRARY")
	endif (NOT ${project_type} STREQUAL "EXECUTABLE" AND NOT ${project_type} STREQUAL "LIBRARY" )
	if ( ${project_type} STREQUAL "LIBRARY" 
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "STATIC"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "SHARED"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "MODULE"
		)
		message ( FATAL_ERROR " Project Load type ${${PROJECT_NAME}_load_type} is not valid. Project Load type can be either STATIC, SHARED or MODULE")
	endif  ( ${project_type} STREQUAL "LIBRARY" 
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "STATIC"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "SHARED"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "MODULE"
		)
		
	#Verbose Makefile if not release build. Making them internal not to confuse user by appearing with values used only for one project.
	if ( ${PROJECT_NAME}_BUILD_TYPE )
	if (${${PROJECT_NAME}_BUILD_TYPE} STREQUAL Release)
		set(CMAKE_VERBOSE_MAKEFILE OFF CACHE INTERNAL "Verbose build commands disabled for Release build." FORCE)
		set(CMAKE_USE_RELATIVE_PATHS OFF CACHE INTERNAL "Absolute paths used in makefiles and projects for Release build." FORCE)
	else (${${PROJECT_NAME}_BUILD_TYPE} STREQUAL Release)
		message( STATUS "== Non Release build detected : enabling verbose makefile" )
		# To get the actual commands used
		set(CMAKE_VERBOSE_MAKEFILE ON CACHE INTERNAL "Verbose build commands enabled for Non Release build." FORCE)
				#VLD
		set(CHECK_MEM_LEAKS OFF CACHE BOOL "On to check memory with VLD (must be installed)")
		if(CHECK_MEM_LEAKS)
			add_definitions(-DVLD)
		endif(CHECK_MEM_LEAKS)
	endif (${${PROJECT_NAME}_BUILD_TYPE} STREQUAL Release)
	endif ( ${PROJECT_NAME}_BUILD_TYPE )

	#generating configured Header for detected packages
	WkPlatformConfigure()

	#Storing Main Include directory
	#set( ${PROJECT_NAME}_INCLUDE_DIRS "${PROJECT_SOURCE_DIR}/${WKCMAKE_INCLUDE_DIR}" CACHE PATH " Includes directories for ${PROJECT_NAME} blah ")
	
	#Defining target
	message ( STATUS "== Sources Files autodetection..." )	

	#VS workaround to display headers even if strictly not needd when building
	FILE(GLOB_RECURSE HEADERS RELATIVE "${PROJECT_SOURCE_DIR}" ${WKCMAKE_INCLUDE_DIR}/*.h ${WKCMAKE_INCLUDE_DIR}/*.hh ${WKCMAKE_INCLUDE_DIR}/*.hpp ${WKCMAKE_SRC_DIR}/*.h ${WKCMAKE_SRC_DIR}/*.hh ${WKCMAKE_SRC_DIR}/*.hpp)
	FILE(GLOB_RECURSE SOURCES RELATIVE "${PROJECT_SOURCE_DIR}" ${WKCMAKE_SRC_DIR}/*.c ${WKCMAKE_SRC_DIR}/*.cpp ${WKCMAKE_SRC_DIR}/*.cc)
	message ( STATUS "== Headers detected in ${WKCMAKE_INCLUDE_DIR} and ${WKCMAKE_SRC_DIR} : ${HEADERS}" )
	message ( STATUS "== Sources detected in ${WKCMAKE_SRC_DIR} : ${SOURCES}" )

	if ( NOT CMAKE_MODULE_PATH )
		set(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH}" "${CMAKE_SOURCE_DIR}/${WKCMAKE_DIR}/Modules/")
	endif ( NOT CMAKE_MODULE_PATH )

	FIND_PACKAGE(AStyle)
	IF ( AStyle_FOUND )
		option (${PROJECT_NAME}_CODE_FORMAT "Enable Code Formatting" ON)
		IF ( ${PROJECT_NAME}_CODE_FORMAT )
			set(${PROJECT_NAME}_CODE_FORMAT_STYLE "ansi" CACHE STRING "Format Style for AStyle")
			WkWhitespaceSplit( HEADERS HEADERS_PARAM )
			WkWhitespaceSplit( SOURCES SOURCES_PARAM )
			#message ( "Sources :  ${HEADERS_PARAM} ${SOURCES_PARAM}" )
			set ( cmdline " ${AStyle_EXECUTABLE} --style=${${PROJECT_NAME}_CODE_FORMAT_STYLE} ${HEADERS_PARAM} ${SOURCES_PARAM}" )
			#message ( "CMD : ${cmdline} " )
			ADD_CUSTOM_TARGET(${PROJECT_NAME}_format ALL sh -c ${cmdline} WORKING_DIRECTORY "${PROJECT_SOURCE_DIR}" VERBATIM )
		ENDIF ( ${PROJECT_NAME}_CODE_FORMAT )
	ENDIF ( AStyle_FOUND )


	#Including configured headers (
	#	-binary_dir/CMakeFiles for the configured header, 
	#	-source_dir/include for the unmodified ones, 
	include_directories("${PROJECT_BINARY_DIR}/CMakeFiles" "${PROJECT_SOURCE_DIR}/${WKCMAKE_INCLUDE_DIR}" )

	#internal headers ( non visible by outside project )
	include_directories("${PROJECT_SOURCE_DIR}/${WKCMAKE_SRC_DIR}")

	#TODO : find a simpler way than this complex merge...
	MERGE("${HEADERS}" "${SOURCES}" SOURCES)
	#MESSAGE ( STATUS "== ${PROJECT_NAME} Sources : ${SOURCES}" )
	
	AddPlatformCheckSrc( SOURCES )

	#
	# Handling my own build config
	#
	
	# to show we are using WkCMake to build ( can be #ifdef in header )
	add_definitions( -D WK_BUILD )

	if(${project_type} STREQUAL "LIBRARY")
		add_library(${PROJECT_NAME} ${${PROJECT_NAME}_load_type} ${SOURCES})
		if ( ${PROJECT_NAME}_load_type )
		if(${${PROJECT_NAME}_load_type} STREQUAL "SHARED")
			set_target_properties(${PROJECT_NAME} PROPERTIES DEFINE_SYMBOL "WK_${PROJECT_NAME}_SHAREDLIB_BUILD")
			#if on windows we need to care about run libraries ( Dlls )
			if ( WIN32 )
				get_target_property(${PROJECT_NAME}_LOCATION ${PROJECT_NAME} LOCATION)
				set( ${PROJECT_NAME}_RUN_LIBRARIES "${${PROJECT_NAME}_LOCATION}")
				#message( "Project run lib WkBuild : ${${PROJECT_NAME}_RUN_LIBRARIES} " )
			endif( WIN32 )
		endif(${${PROJECT_NAME}_load_type} STREQUAL "SHARED")
		endif (${PROJECT_NAME}_load_type)		
	elseif (${project_type} STREQUAL "EXECUTABLE")
		add_executable(${PROJECT_NAME} ${SOURCES})
		#We also need to copy run libraries on windows
		
	else ()
		message( FATAL_ERROR " Project Type can only be EXECUTABLE or LIBRARY " )
	endif()
	
	if( AStyle_FOUND )
		add_dependencies(${PROJECT_NAME} format)
	endif( AStyle_FOUND )

	#
	# Defining where to put what has been built
	#
	
	SET(${PROJECT_NAME}_LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/${WKCMAKE_LIB_DIR} CACHE PATH "Ouput directory for ${Project} libraries." )
	mark_as_advanced(FORCE ${PROJECT_NAME}_LIBRARY_OUTPUT_PATH)
	SET(LIBRARY_OUTPUT_PATH "${${PROJECT_NAME}_LIBRARY_OUTPUT_PATH}" CACHE INTERNAL "Internal CMake libraries output directory. Do not edit." FORCE)
	
	SET(${PROJECT_NAME}_EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/${WKCMAKE_BIN_DIR} CACHE PATH "Ouput directory for ${Project} executables." )
	mark_as_advanced(FORCE ${PROJECT_NAME}_EXECUTABLE_OUTPUT_PATH)
	SET(EXECUTABLE_OUTPUT_PATH "${${PROJECT_NAME}_EXECUTABLE_OUTPUT_PATH}" CACHE INTERNAL "Internal CMake executables output directory. Do not edit." FORCE)

	#
	# Copying include directory if needed after build ( for  use by another project later )
	# for library (and modules ? )
	#
	
	if(${project_type} STREQUAL "LIBRARY") 
		ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} ARGS -E copy_directory "${PROJECT_SOURCE_DIR}/${WKCMAKE_INCLUDE_DIR}" "${PROJECT_BINARY_DIR}/${WKCMAKE_INCLUDE_DIR}" COMMENT "Copying ${PROJECT_SOURCE_DIR}/${WKCMAKE_INCLUDE_DIR} to ${PROJECT_BINARY_DIR}/${WKCMAKE_INCLUDE_DIR}" )
		#trying to remove .svn directory... pb : what about other directories everywhere ?
		ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} ARGS -E remove_directory "${PROJECT_BINARY_DIR}/${WKCMAKE_INCLUDE_DIR}/.svn" COMMENT "Removing ${PROJECT_BINARY_DIR}/${WKCMAKE_INCLUDE_DIR}/.svn" )
	endif(${project_type} STREQUAL "LIBRARY") 
	
	#
	# Copying data directory after build ( fo use by project later )
	#
	ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} ARGS -E copy_directory "${PROJECT_SOURCE_DIR}/${WKCMAKE_DATA_DIR}" "${PROJECT_BINARY_DIR}/${WKCMAKE_DATA_DIR}" COMMENT "Copying ${PROJECT_SOURCE_DIR}/${WKCMAKE_DATA_DIR} to ${PROJECT_BINARY_DIR}/${WKCMAKE_DATA_DIR}" )

	#
	# Generating configuration cmake file
	#
	
	WkGenConfig( )
	
	#Linking dependencies, and modifying config files
	foreach (dep ${${PROJECT_NAME}_DEPENDS} )
		WkLinkDepends( ${dep} )
	endforeach()

	WkFinConfig()
		
CMAKE_POLICY(POP)
endmacro (WkBuild)

#
# WkExtData( [ datafile1 [ datafile2 [ ... ] ] ] )
# Copy the external data ( not in WKCMAKE_DATA_DIR ) associated to the project from the path,
# to the binary_path, in the WKCMAKE_DATA_DIR directory
#
MACRO (WkExtData)

	foreach ( data ${ARGN} )
		ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} ARGS -E copy_if_different ${data} ${PROJECT_BINARY_DIR}/${WKCMAKE_DATA_DIR}/${data} COMMENT "Copying ${data} to ${PROJECT_BINARY_DIR}/${WKCMAKE_DATA_DIR}/${data}" )
	endforeach ( data ${ARGN} )
	
ENDMACRO (WkExtData data_path)

#
# WkExtDataDir( [ datadir1 [ datadir2 [ ... ] ] ] )
# Copy the external data directory ( not in WKCMAKE_DATA_DIR ) associated to the project from the path,
# to the binary_path, in the WKCMAKE_DATA_DIR directory
#
MACRO (WkExtDataDir)

	foreach ( datadir ${ARGN} )
		ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} ARGS -E copy_directory ${datadir} ${PROJECT_BINARY_DIR}/${WKCMAKE_DATA_DIR}/${datadir} COMMENT "Copying ${datadir} to ${PROJECT_BINARY_DIR}/${WKCMAKE_DATA_DIR}/${datadir}" )
	endforeach ( datadir ${ARGN} )
	
ENDMACRO (WkExtDataDir data_path)




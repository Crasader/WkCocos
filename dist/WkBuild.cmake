# 
# Copyright (c) 2009, Asmodehn's Corp.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
# 
#     * Redistributions of source code must retain the above copyright notice, 
#	    this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#		notice, this list of conditions and the following disclaimer in the 
#	    documentation and/or other materials provided with the distribution.
#     * Neither the name of the Asmodehn's Corp. nor the names of its 
#	    contributors may be used to endorse or promote products derived
#	    from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
#

if ( CMAKE_BACKWARDS_COMPATIBILITY LESS 2.6 )
	message ( FATAL_ERROR " CMAKE MINIMUM BACKWARD COMPATIBILITY REQUIRED : 2.6 !" )
endif( CMAKE_BACKWARDS_COMPATIBILITY LESS 2.6 )


#To setup the compiler
include ( CMake/WkCompilerSetup.cmake )
include ( CMake/WkFind.cmake )

macro(WKProject project_name_arg)
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)
	project(${project_name_arg} ${ARGN})
	WkCompilerSetup( )
	#preparing and cleaning internal build variables
	set( ${PROJECT_NAME}_INCLUDE_DIRS CACHE INTERNAL " Includes directories for ${PROJECT_NAME} ")
	set( ${project_name_arg}_LIBRARIES CACHE INTERNAL " libraries needed for ${target_name} " )
	set( ${project_name_arg}_RUN_LIBRARIES CACHE INTERNAL " libraries needed to run ${target_name} " )
CMAKE_POLICY(POP)
endmacro(WKProject PROJECT_NAME)

MACRO(MERGE ALIST BLIST OUTPUT)
   SET(BTEMP ${BLIST})
   FOREACH(A ${ALIST})
       SET(SORTED)
       SET(UNINSERTED 1)
       FOREACH(B ${BTEMP})
           IF(${UNINSERTED})
               IF(${A} STRLESS ${B})
                   SET(SORTED ${SORTED} ${A})
                   SET(UNINSERTED 0)
               ENDIF(${A} STRLESS ${B})
           ENDIF(${UNINSERTED})
           SET(SORTED ${SORTED} ${B})
       ENDFOREACH(B ${BLIST})
       IF(${UNINSERTED})
           SET(SORTED ${SORTED} ${A})
       ENDIF(${UNINSERTED})
       SET(BTEMP ${SORTED})
   ENDFOREACH(A ${ALIST})
   SET(${OUTPUT} ${BTEMP})
ENDMACRO(MERGE ALIST BLIST OUTPUT)

#
# Macro to store include directories in a variable, to have built binary similar to an installed package already found...
#
# macro (  WkIncludeDirectories [dir [...] ] )

macro (  WkIncludeDirectories )
	foreach ( loopdir ${ARGN} )
		include_directories(${loopdir})
		set( ${PROJECT_NAME}_INCLUDE_DIRS ${${PROJECT_NAME}_INCLUDE_DIRS} ${loopdir} CACHE INTERNAL " Includes directories for ${PROJECT_NAME} ")
	endforeach ( loopdir ${ARGN} )
endmacro (  WkIncludeDirectories )

#
# Macro to store linked libraries in a variable, to have built binary similar to an installed package already found...
#
# macro (  WkLinkLibraries target_name [lib [...] ] )

macro ( WkLinkLibraries target_name )
	foreach ( looplib ${ARGN} )
		target_link_libraries(${target_name} ${looplib})
		set( ${target_name}_LIBRARIES ${${PROJECT_NAME}_LIBRARIES} ${looplib} CACHE INTERNAL " libraries needed for ${target_name} " )
	endforeach ( looplib ${ARGN} )
endmacro (  WkLinkLibraries target_name)


#
# Macro to store run libraries in a variable, to have built binary similar to an installed package already found...
#
# macro (  WkRunLibraries  target_name[lib [...] ] )

macro (  WkRunLibraries target_name )
	foreach ( looplib ${ARGN} )
		set( ${target_name}_RUN_LIBRARIES ${${PROJECT_NAME}_RUN_LIBRARIES} ${looplib} CACHE INTERNAL " libraries needed to run ${target_name} " )
	endforeach ( looplib ${ARGN} )
endmacro (  WkRunLibraries target_name)

#
# Generate a config file for the project.
#
# Automatically called after WkBuild
#

macro ( WkGenConfig )
	#Exporting targets
	export(TARGETS ${PROJECT_NAME} ${${PROJECT_NAME}_source_depends} FILE ${PROJECT_NAME}Export.cmake)
	
	#Generating config file
	file( WRITE ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "### Config file for ${PROJECT_NAME} auto generated by WkCmake ###

IF("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.5)
   MESSAGE(FATAL_ERROR "CMake >= 2.6.0 required")
ENDIF("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.5)
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)
### First section : Main target ###
	
get_filename_component(SELF_DIR \"\${CMAKE_CURRENT_LIST_FILE}\" PATH)
#all required target should be defined there... no need to specify all targets in ${PROJECT_NAME}_LIBRARIES, they will be linked automatically
include(\${SELF_DIR}/${PROJECT_NAME}Export.cmake)
get_filename_component(${PROJECT_NAME}_INCLUDE_DIR "\${SELF_DIR}/include/" ABSOLUTE)
set(${PROJECT_NAME}_INCLUDE_DIRS \${${PROJECT_NAME}_INCLUDE_DIR})
	")
	
	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
#however we still want to have ${PROJECT_NAME}_LIBRARIES available
#getting full path for the library, 
get_target_property(${PROJECT_NAME}_IMPORTED_IMPLIB ${PROJECT_NAME} IMPORTED_IMPLIB)
set(${PROJECT_NAME}_LIBRARY \${${PROJECT_NAME}_IMPORTED_IMPLIB})
set(${PROJECT_NAME}_LIBRARIES \${${PROJECT_NAME}_LIBRARY})
	" )
	
	get_target_property(${PROJECT_NAME}_LOCATION ${PROJECT_NAME} LOCATION)
	get_target_property(${PROJECT_NAME}_TYPE ${PROJECT_NAME} TYPE)
	if ( ${${PROJECT_NAME}_TYPE} STREQUAL "SHARED_LIBRARY" OR ${${PROJECT_NAME}_TYPE} STREQUAL "MODULE_LIBRARY")
		file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
get_target_property(${PROJECT_NAME}_LOCATION ${PROJECT_NAME} LOCATION)
set(${PROJECT_NAME}_RUN_LIBRARIES \${${PROJECT_NAME}_RUN_LIBRARIES} \${${PROJECT_NAME}_LOCATION})
		")
	endif ( ${${PROJECT_NAME}_TYPE} STREQUAL "SHARED_LIBRARY" OR ${${PROJECT_NAME}_TYPE} STREQUAL "MODULE_LIBRARY")
	
	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
set(${PROJECT_NAME}_FOUND TRUE)
	")	
	
	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
### Second Section : Source dependencies ###
	")
	
	foreach( looparg ${${PROJECT_NAME}_source_depends} )
		file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
get_filename_component(${looparg}_INCLUDE_DIR \"\${PROJECT_BINARY_DIR}/ext/${looparg}_build/include\" ABSOLUTE)
set(${PROJECT_NAME}_INCLUDE_DIRS \${${PROJECT_NAME}_INCLUDE_DIRS} \${${looparg}_INCLUDE_DIR})
		")
		
	get_target_property(${looparg}_LOCATION ${looparg} LOCATION)
	get_target_property(${looparg}_TYPE ${looparg} TYPE)
	if ( ${${looparg}_TYPE} STREQUAL "SHARED_LIBRARY" OR ${${looparg}_TYPE} STREQUAL "MODULE_LIBRARY")
		file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
set(${PROJECT_NAME}_RUN_LIBRARIES \${${PROJECT_NAME}_RUN_LIBRARIES} \${${looparg}_LOCATION})
		")
	endif ( ${${looparg}_TYPE} STREQUAL "SHARED_LIBRARY" OR ${${looparg}_TYPE} STREQUAL "MODULE_LIBRARY")
	
		
	endforeach( looparg ${${PROJECT_NAME}_source_depends} )
	
	
	foreach( looparg ${${PROJECT_NAME}_source_depends} )
		file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
		#This is fine because we know the dependency target, and it will be exported along with the main target
set(${looparg}_LIBRARY ${looparg})
set(${looparg}_LIBRARIES \${${looparg}_LIBRARIES} \${${looparg}_LIBRARY})
		")
		
	endforeach( looparg ${${PROJECT_NAME}_source_depends} )
	
	file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "
CMAKE_POLICY(POP)
	")
	
endmacro ( WkGenConfig )


#
# Configure and Build process based on well-known hierarchy
# You need include and src in your hierarchy at least for this to work correctly
# You also need MergeLists.txt 
#

#WkBuild( target_name EXECUTABLE | LIBRARY [ STATIC|SHARED|MODULE ]  )

macro (WkBuild project_type )
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)

	if ( ${ARGC} GREATER 1 )
		set(${PROJECT_NAME}_load_type ${ARGV1} )
	endif ( ${ARGC} GREATER 1 )

	message ( STATUS "Configuring ${PROJECT_NAME} as ${project_type} ${${PROJECT_NAME}_load_type}" )	
		
	# testing type
	if (NOT ${project_type} STREQUAL "EXECUTABLE" AND NOT ${project_type} STREQUAL "LIBRARY" )
		message ( FATAL_ERROR " Project type ${project_type} is not valid. Project type can be either EXECUTABLE or LIBRARY")
	endif (NOT ${project_type} STREQUAL "EXECUTABLE" AND NOT ${project_type} STREQUAL "LIBRARY" )
	if ( ${project_type} STREQUAL "LIBRARY" 
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "STATIC"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "SHARED"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "MODULE"
		)
		message ( FATAL_ERROR " Project Load type ${${PROJECT_NAME}_load_type} is not valid. Project Load type can be either STATIC, SHARED or MODULE")
	endif  ( ${project_type} STREQUAL "LIBRARY" 
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "STATIC"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "SHARED"
					AND NOT ${${PROJECT_NAME}_load_type} STREQUAL "MODULE"
		)
	
		#Building dependencies recursively ( not looking into hidden directories (beginning with '.' or '..') )
		
		file(GLOB ${PROJECT_NAME}_sourcedir_depends RELATIVE ${PROJECT_SOURCE_DIR} ext/[^.]* )
		#to get rid of the ext/ prefix
		set(${PROJECT_NAME}_source_depends)
		foreach ( looparg ${${PROJECT_NAME}_sourcedir_depends} )
			get_filename_component( dependency_project ${looparg} NAME)
			list( APPEND ${PROJECT_NAME}_source_depends ${dependency_project} )
		endforeach ( looparg )
		if (${PROJECT_NAME}_source_depends )
			message ( STATUS "Source Dependencies detected : ${${PROJECT_NAME}_source_depends}" )
		else (${PROJECT_NAME}_source_depends )
			message ( STATUS "Source Dependencies detected : None" )
		endif (${PROJECT_NAME}_source_depends )
		
		if ( ${PROJECT_NAME}_source_depends )
			set(${PROJECT_NAME}_BUILD_SHARED_LIBS ${BUILD_SHARED_LIBS})
			#making sure that by default we build static libraries for source dependencies
			set(BUILD_SHARED_LIBS OFF)
			foreach ( looparg ${${PROJECT_NAME}_source_depends} )
				message ( STATUS "==" )
				message ( STATUS "Cmake'ing dependency ${looparg} : Started." )
				#building in separate build directory in case the father project is built in source...
				add_subdirectory(ext/${looparg} ext/${looparg}_build )
				message ( STATUS "Cmake'ing dependency ${looparg} : Done." )
				message ( STATUS "==" )
				#finding the package that has just been built
				#find_package( ${looparg} NO_MODULE PATHS ext/${looparg}_build )
				#if ( ${looparg}_FOUND )
					WkIncludeDirectories(${${looparg}_INCLUDE_DIRS})
					message ( STATUS " ${PROJECT_NAME} Now including ${${looparg}_INCLUDE_DIRS} ")
				#endif ( ${looparg}_FOUND )
			endforeach ( looparg )
			#MESSAGE ( STATUS "Back to configuring ${PROJECT_NAME} build" )
			set( BUILD_SHARED_LIBS ${${PROJECT_NAME}_BUILD_SHARED_LIBS} )
		endif ( ${PROJECT_NAME}_source_depends )	
	
	#Verbose Makefile if not release build. Making them internal not to confuse user by appearing with values used only for one project.
	if (${${PROJECT_NAME}_BUILD_TYPE} STREQUAL Release)
		set(CMAKE_VERBOSE_MAKEFILE OFF CACHE INTERNAL "Verbose build commands disabled for Release build." FORCE)
		set(CMAKE_USE_RELATIVE_PATHS OFF CACHE INTERNAL "Absolute paths used in makefiles and projects for Release build." FORCE)
	else (${${PROJECT_NAME}_BUILD_TYPE} STREQUAL Release)
		message( STATUS "Non Release build detected : enabling verbose makefile" )
		# To get the actual commands used
		set(CMAKE_VERBOSE_MAKEFILE ON CACHE INTERNAL "Verbose build commands enabled for Non Release build." FORCE)
				#VLD
		set(CHECK_MEM_LEAKS OFF CACHE BOOL "On to check memory with VLD (must be installed)")
		if(CHECK_MEM_LEAKS)
			add_definitions(-DVLD)
		endif(CHECK_MEM_LEAKS)
	endif (${${PROJECT_NAME}_BUILD_TYPE} STREQUAL Release)

	#Defining target
	
	#VS workaround to display headers
	FILE(GLOB_RECURSE HEADERS RELATIVE ${PROJECT_SOURCE_DIR} include/*.h include/*.hh include/*.hpp)
	FILE(GLOB_RECURSE SOURCES RELATIVE ${PROJECT_SOURCE_DIR} src/*.c src/*.cpp src/*.cc)

	#Including configured headers (
	#	-binary_dir for the configured header,  (useful ? )
	#	-Cmake for Wk headers
	#	-include for the unmodified ones, 
	#	-and in source/src for internal ones)
	WkIncludeDirectories( ${PROJECT_SOURCE_DIR}/CMake ${PROJECT_SOURCE_DIR}/include )
	#internal headers ( non visible by outside project )
	include_directories(${PROJECT_SOURCE_DIR}/src)

	#TODO : find a simpler way than this complex merge...
	MERGE("${HEADERS}" "${SOURCES}" SOURCES)
	#MESSAGE ( STATUS "Sources : ${SOURCES}" )
	
	#
	# Handling my own build config
	#
	
	if(${project_type} STREQUAL "LIBRARY")
		add_library(${PROJECT_NAME} ${${PROJECT_NAME}_load_type} ${SOURCES})
		set( ${PROJECT_NAME}_LIBRARIES ${PROJECT_NAME} CACHE INTERNAL " libraries needed for ${target_name} " )
		if ( ${PROJECT_NAME}_load_type )
		if(${${PROJECT_NAME}_load_type} STREQUAL "SHARED")
			set_target_properties(${PROJECT_NAME} PROPERTIES DEFINE_SYMBOL "WK_SHAREDLIB_BUILD")
			get_target_property(${PROJECT_NAME}_LOCATION ${PROJECT_NAME} LOCATION)
			set( ${PROJECT_NAME}_RUN_LIBRARIES ${${PROJECT_NAME}_LOCATION} CACHE INTERNAL " libraries needed to run ${target_name} " )
		endif(${${PROJECT_NAME}_load_type} STREQUAL "SHARED")
		endif (${PROJECT_NAME}_load_type)		
	elseif (${project_type} STREQUAL "EXECUTABLE")
		add_executable(${PROJECT_NAME} ${SOURCES})
	else (${project_type} STREQUAL "LIBRARY")
		message( FATAL_ERROR " Project Type can only be EXECUTABLE or LIBRARY " )
	endif(${project_type} STREQUAL "LIBRARY")

	#
	# Handling Sources dependencies
	#
	
	foreach ( looparg ${${PROJECT_NAME}_source_depends} )
		WkLinkLibraries(${PROJECT_NAME} ${${looparg}_LIBRARIES})
		message ( STATUS " ${PROJECT_NAME} Now linking with ${${looparg}_LIBRARIES} ")
		#to make sur the source dependencies are built before
		add_dependencies( ${PROJECT_NAME} ${looparg} )
		#if the find module also defines the runtime libraries ( Wk find module convention)
		WkRunLibraries( ${PROJECT_NAME} ${${package_name}_RUN_LIBRARIES} )
		message ( STATUS " ${PROJECT_NAME} Now running with ${${looparg}_RUN_LIBRARIES} ")
	endforeach ( looparg ${${PROJECT_NAME}_source_depends} )
	

	
	
	#
	# Defining where to put what has been built
	#
	
	SET(${PROJECT_NAME}_LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib CACHE PATH "Ouput directory for ${Project} libraries." )
	mark_as_advanced(FORCE ${PROJECT_NAME}_LIBRARY_OUTPUT_PATH)
	SET(LIBRARY_OUTPUT_PATH "${${PROJECT_NAME}_LIBRARY_OUTPUT_PATH}" CACHE INTERNAL "Internal CMake libraries output directory. Do not edit." FORCE)
	
	SET(${PROJECT_NAME}_EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin CACHE PATH "Ouput directory for ${Project} executables." )
	mark_as_advanced(FORCE ${PROJECT_NAME}_EXECUTABLE_OUTPUT_PATH)
	SET(EXECUTABLE_OUTPUT_PATH "${${PROJECT_NAME}_EXECUTABLE_OUTPUT_PATH}" CACHE INTERNAL "Internal CMake executables output directory. Do not edit." FORCE)

	#
	# Copying include directory if needed after build ( for  use by another project later )
	# for library (and modules ? )
	#
	
	if(${project_type} STREQUAL "LIBRARY") 
		ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} ARGS -E copy_directory ${PROJECT_SOURCE_DIR}/include ${PROJECT_BINARY_DIR}/include
													COMMENT "Copying ${PROJECT_SOURCE_DIR}/include to ${PROJECT_BINARY_DIR}" )
	endif(${project_type} STREQUAL "LIBRARY") 
	

	#
	# Generating configuration cmake file
	#
	
	WkGenConfig( )
	
	#
	# Generating the findProject.cmake in case external projects want to use it...
	#
	
	WkGenFind( )
	
CMAKE_POLICY(POP)
endmacro (WkBuild)


#
# Find a dependency built in an external WK hierarchy
# Different than for a package because this dependency hasnt been installed yet.
#
# WkBinDepends( dependency_name [QUIET] [REQUIRED] )

macro (WkDepends package_name)
CMAKE_POLICY(PUSH)
CMAKE_POLICY(VERSION 2.6)
	
	#
	# First check if the package is installed already , quietly
	#
	
	find_package( ${package_name} ${ARGN} )
	if ( ${package_name}_FOUND )
		message ( STATUS "Binary Dependency ${package_name} : Found ! " )
		WkIncludeDirectories(${${package_name}_INCLUDE_DIRS})
		WkLinkLibraries(${PROJECT_NAME} ${${package_name}_LIBRARIES})
		#if the find module also defines the runtime libraries ( Wk find module standard )
		WkRunLibraries(${PROJECT_NAME} ${${package_name}_RUN_LIBRARIES} )
		#once the project is built with it the dependency becomes mandatory
		# we append to the config cmake script
		file( APPEND ${PROJECT_BINARY_DIR}/${PROJECT_NAME}Config.cmake "

### External Dependency ${package_name} ###
		
find_package( ${package_name} REQUIRED )
if ( ${package_name}_FOUND )
	set(${PROJECT_NAME}_INCLUDE_DIRS \${${PROJECT_NAME}_INCLUDE_DIRS} \${${package_name}_INCLUDE_DIRS} )
	set(${PROJECT_NAME}_LIBRARIES \${${PROJECT_NAME}_LIBRARIES} \${${package_name}_LIBRARIES} )
	set(${PROJECT_NAME}_RUN_LIBRARIES \${${PROJECT_NAME}_RUN_LIBRARIES} \${${package_name}_RUN_LIBRARIES} )
endif ( ${package_name}_FOUND )
		
		")
		
	else ( ${package_name}_FOUND )	
		message ( STATUS "Binary Dependency ${package_name} : FAILED ! " )
	endif ( ${package_name}_FOUND )
	
	# probably belongs somewhere else
	#set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake/Modules/")
	
CMAKE_POLICY(POP)
endmacro (WkDepends package_name)


